         ;代码清单11-1
         ;文件名：c11_mbr.asm
         ;文件说明：硬盘主引导扇区代码 
         ;创建日期：2011-5-16 19:54

          ;BIOS将引导设备的第一个扇区加载在内存地址0x7c00中
          ; http://www.ruanyifeng.com/blog/2015/09/0x7c00.html

         ;设置堆栈段和栈指针 
         mov ax,cs      
         mov ss,ax
         mov sp,0x7c00
      
          ; GDT是全局描述符表，记录了每段的基址、长度、权限等，保存在内存中
          ; 当进入保护模式前，需要在实模式下，先写好GDT，然后把GDT的基址和界限加载到GDTR寄存器中

         ;计算GDT所在的逻辑段地址 
         ; [cs:gdt_base+0x7c00] 就是把gdt_base里的值(0x7e00)取出来
         ; 加0x7c00是因为这是代码段的基地址
         mov ax,[cs:gdt_base+0x7c00]        ;低16位 
         mov dx,[cs:gdt_base+0x7c00+0x02]   ;高16位 
         mov bx,16        
         div bx   ;将DX:AX除以16，得到的商ax是逻辑段地址，余dx是偏移地址       
         mov ds,ax                          ;令DS指向该段以进行操作
         mov bx,dx                          ;段内起始偏移地址 
      
         ;创建0#描述符，它是空描述符，这是处理器的要求
         mov dword [bx+0x00],0x00
         mov dword [bx+0x04],0x00  

         ;创建#1描述符，保护模式下的代码段描述符
         ; 段基地址 = 1(31~24) /*第1个4字节的第31~24位，代表段基址的31~24位*/+ 1(7~0) + 0(31~16) /*0~16位*/
         ;         = 0x00 + 0x00 + 0x7c00 = 0x00007c00
         ; 段界限 = 1(16~19) + 0(0~15) 段界限是允许访问的最高端偏移地址
         ;       = 0x0 + 0x01ff = 0x001ff 根据粒度G，该段长512字节
         ; TYPE 1(8-11)=0x8 or前面是数据段的后面是代码段的
         ;   = X位（代码段）：1 + E位（向下扩展）or C位（依从）：0 + W位（写）orR位（读）：0+ A位（已访问）：0
         ; 0000无效字段
         ; S 描述符类型 = 1(12) = 1 为0代表是系统段，1代表数据段或代码段
         ; DPL 特权级 = 1(13~14) = 0 0最高特权 3最低特权
         ; P 段存在位 = 1(15) = 1 该段是否存在内存中，当空间紧张时，会被腾出到硬盘，并置0
         ; AVL 1(20) = 0 多余的位
         ; L 64位代码段标志 = 1(21) = 0
         ; D/B 默认的操作数大小/默认的栈指针大小 = 1(22) = 1 这是32位的段
         ; G 粒度位 = 1(23) = 0 为0代表段界限以字节为单位，为1代表以4KB为单位（此时段界限=段界限值*0x1000+0xfff)

         mov dword [bx+0x08],0x7c0001ff     
         mov dword [bx+0x0c],0x00409800     

         ;创建#2描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区）
         ; 段基址 = 0x00 + 0x0b + 0x8000 = 0x000b8000
         ; 段界限 = 0x0 + 0xffff = 0x0ffff
         ; TYPE = 0x2 = 可读写,向上拓展的数据段
         ; S = 1 , DPL = 0 , P=1
         ; AVL =0 , L =0 ,D =1 ,G=0
         mov dword [bx+0x10],0x8000ffff     
         mov dword [bx+0x14],0x0040920b     

         ;创建#3描述符，保护模式下的堆栈段描述符
         ; 段基址 = 0x00 + 0x00 + 0x0000 
         ; 段界限 = 0x0 + 0x7a00 因为是向下拓展,所以段界限是不允许访问的最低端偏移地址
         ; TYPE = 0x6 = 可读写向下拓展的数据段
         ; 同上
         mov dword [bx+0x18],0x00007a00
         mov dword [bx+0x1c],0x00409600

         ;初始化描述符表寄存器GDTR
         ;给gdt_size赋值
         mov word [cs: gdt_size+0x7c00],31  ;描述符表的界限（总字节数减一）
         ;lgdt []中的地址要指向一个48位的内存数据，里面前16位是GDT的界限，后32位是GDT的基址。
         ; 把gdt_size开始6个字节（也就是上一行说的那些东西）加载到GDTR寄存器
         lgdt [cs: gdt_size+0x7c00]
      
         ;历史遗留问题，不用管
         in al,0x92                         ;南桥芯片内的端口 
         or al,0000_0010B
         out 0x92,al                        ;打开A20

         cli                                ;保护模式下中断机制尚未建立， 
                                            ;应禁止中断 
         ; cr0寄存器的0位(PE位)控制保护模式
         mov eax,cr0
         or eax,1
         mov cr0,eax                        ;设置PE位
      
         ;以下进入保护模式... ...
         ;
         ; 由于实模式下代码按16位操作数和16位地址长度进行译码，如果进入保护模式后执行的代码是bits 32编译的，那么流水线会出问题。
         ; 所以要立即清空流水线，建议立即jmp
         ; 因为，cpu遇到远距离跳转指令如jmp或call，一般都会清空流水线。
         ; 
         ; 下面的jmp使用0x0008是因为这里还是按16位编译
         ; 但是 由于加了 dword 最后的偏移量会是32位，属于32位远转移
         ; 如果没有dword，那么就是16位的偏移量了
         ; 因为这段代码位于
         ; 
         ; 而且注意，因为进入了保护模式，所以一律使用段选择子：0x0008
         jmp dword 0x0008:flush             ;16位的描述符选择子：32位偏移
                                             ;清流水线并串行化处理器 

         [bits 32]       ;伪指令，下面的代码会按照bits 32编译

    flush:
          ;实模式的地址计算方法是 段寄存器里的值*16+偏移：
          ; mov cx,0x2000
          ; mod ds,cx
          ; mov [0xc0],al ;此时[0xc0]=[ds*16+0xc0]

          ; 保护模式下 段寄存器变成段选择器
          ; 段选择器保存的不是基址，而是段选择子：
          ; (描述符表中的索引号(12位),TI(1位, =0 GDT,=1 LDT),RPL(2位，给出选择子的程序的特权))
          ; cpu里有隐藏的段描述符寄存器保存段基址、描述符，不会每次都计算

          ;顺便注意，保护模式下不能用mov指令改变段寄存器cs

         mov cx,00000000000_10_000B         ;加载数据段选择子(0x10)
         mov ds,cx

         ;以下在屏幕上显示"Protect mode OK." 
         mov byte [0x00],'P'  
         mov byte [0x02],'r'
         mov byte [0x04],'o'
         mov byte [0x06],'t'
         mov byte [0x08],'e'
         mov byte [0x0a],'c'
         mov byte [0x0c],'t'
         mov byte [0x0e],' '
         mov byte [0x10],'m'
         mov byte [0x12],'o'
         mov byte [0x14],'d'
         mov byte [0x16],'e'
         mov byte [0x18],' '
         mov byte [0x1a],'O'
         mov byte [0x1c],'K'

         ;以下用简单的示例来帮助阐述32位保护模式下的堆栈操作 
         mov cx,00000000000_11_000B         ;加载堆栈段选择子
         mov ss,cx
         mov esp,0x7c00

         mov ebp,esp                        ;保存堆栈指针 
         push byte '.'                      ;压入立即数（字节）
         
         sub ebp,4
         cmp ebp,esp                        ;判断压入立即数时，ESP是否减4 
         jnz ghalt                          
         pop eax
         mov [0x1e],al                      ;显示句点 
      
  ghalt:     
         hlt                                ;已经禁止中断，将不会被唤醒 

;-------------------------------------------------------------------------------
     
         gdt_size         dw 0
         gdt_base         dd 0x00007e00     ;GDT的物理地址 
       
       ; times 表示重复指令多少次
       ; $等于当前指令地址，$$等于当前汇编节（段）的起始汇编地址
         times 510-($-$$) db 0 
                          db 0x55,0xaa  ;BIOS检查第一个扇区(512)的最后两字节